Quickstart
==========

.. note:: Here we only discuss RV-Monitor for Java.
    Variants of RV-Monitor for C and for LLVM are also available.
    Please contact us if interested in those.

Overview
--------

At its core, RV-Monitor allows you to specify properties that your system
should satisfy at runtime (safety or security properties, API protocols, etc.)
and then to generate efficient monitoring libraries from them.
The generated libraries can then be used either manually, by calling the
monitoring methods at the desired places in your application code, or
automatically, by inserting calls to the monitoring methods using
instrumentation mechanisms.
As an example of the latter, the RV-Monitor distribution also includes
a Java agent that incorporates an RV-Monitor library generated from more
than 200 Java API protocol properties, as well as a command, ``rv-monitor-all``,
that can be used as a drop in replacement of ``java`` when you want the
executed program to be checked against all those properties.

.. note:: If you want to just quickly use RV-Monitor out-of-the-box and
    spend no time on learning how to customize it to your specific needs,
    then just replace ``java`` in your command line
    with ``rv-monitor-all``.  Your program should execute normally
    (but slightly slower) and violations to any of the 200 bundled Java API
    protocols will be reported during the execution of the program.
    While revising the reported violations, remember that you can
    fully configure the properties to be checked and the actions to take
    when they are violated.
    

When a specification is violated or validated at runtime, user-defined actions
will be triggered, which can be any code from information logging to runtime
recovery.
One can understand RV-Monitor from at least three perspectives: 
(1) as a discipline allowing one to improve safety, reliability and
dependability of a system by monitoring its requirements against its
implementation at runtime;
(2) as an extension of programming languages with logics (one can add
logical statements anywhere in the program, referring to past or future
states);
and (3) as a lightweight formal method.

RV-Monitor takes as input one or more specification files and generates Java
classes that  implement the monitoring functionality defined therein.
Each RV-Monitor specification defines a number of *events*, which represent
abstractions of certain points in programs, e.g., a call to the `hasNext()`
method in Java, or closing a file.
With these event abstractions in mind, a user can define
one or more properties over the events, taking the events as either atoms in
logical formulae or as symbols in formal language descriptions.  For example,
one may use these events as symbols in a regular expression or as atoms in a
linear temporal logic formula.
In the generated Java class, each event becomes a method that can be either
called manually by a user or by using some means of instrumentation,
such as AspectJ.  

Each specification also has a number of handlers associated with each property
that are run when their associated property matches some specific conditions.
For instance, when a regular expression pattern matches, we run a handler
designated with the keyword ``@match``, and when an LTL formula is violated, we
run a handler designated with the keyword ``@violation``.
Additionally, RV-Monitor has the capability to generate monitors that enforce
a given property by delaying threads in multi-threaded programs.

First Steps
--------------------------------

The event methods generated by RV-Monitor can be manually called from your
code, or you can automatically *instrument* your code to call them.
Manual calls may look tedious at first, but they allow for fine grain use
of RV-Monitor monitors as a programming paradigm.

For example, consider the RV-Monitor ``HasNext.rvm`` property shown below: ::

    package rvm;
	
    HasNext(Iterator i) {
        event hasnext(Iterator i) {}
        event next(Iterator i) {}
	
        ere : (hasnext hasnext* next)*
	
        @fail {
            System.out.println(
                "! hasNext() has not been called"
                + " before calling next() for an" 
                + " iterator");
                __RESET;
        }
    }
	
The generated Java monitoring library (named ``HasNextRuntimeMonitor`` after
the property) has two methods, one for each event, with the following
signatures::

    public void nextEvent(Iterator i)

and ::

    public void nextEvent(Iterator i)

By calling the methods directly rather than using some sort of automatic
instrumentor, like AspectJ, we can control exactly what we wish to monitor.
For instance, we can add a wrapper class for ``Iterator`` that has versions
of ``hasNext`` and ``next`` that call our monitoring code, and only use them
in places where your code is crucial to be correct.
The class could be defined as follows::

    public class SafeIterator<E> implements java.util.Iterator<E> {
        private java.util.Iterator<E> it;
	
        public SafeIterator(java.util.Iterator it){
            this.it = it;
        }
	
        public boolean hasNext() {
            rvm.HasNextRuntimeMonitor.hasnextEvent(it);
            return it.hasNext();
        } 
	
        public E next(){
            rvm.HasNextRuntimeMonitor.nextEvent(it);
            return it.next();
        }
	
        public void remove(){
            it.remove();
        }
    }

Now our program can distinguish between monitored and unmonitored
``Iterators`` by simply creating ``SafeIterators`` from ``Iterators``.

For example, consider the following program::

    public class Test {
        public static void main(String[] args){
            Vector<Integer> v = new Vector<Integer>();
	
            v.add(1);
            v.add(2);
            v.add(4);
            v.add(8);
	
            Iterator it = v.iterator();
            SafeIterator i = new SafeIterator(it);
            int sum = 0;
	
            if(i.hasNext()){
                sum += (Integer)i.next();
                sum += (Integer)i.next();
                sum += (Integer)i.next();
	            sum += (Integer)i.next();
	        }

	        System.out.println("sum: " + sum);
        }
    }
	
Now let us compile ``SafeIterator.java``, ``Test.java``, and
``HasNextRuntimeMonitor.java``, and then run ``Test.java``.
The ``javac`` and ``java`` commands need ``rvmonitorrt.jar`` and the monitor
directory on your ``CLASSPATH``.
This allows for the use of the RV-Monitor runtime, required by the libraries
generated by the ``rv-monitor`` command.

The commands are structured as follows:

.. code-block:: none

    $ javac -cp [rvmonitorrt.jar]:[monitor directory] InstrumentedProgram(s) MonitorLibrary
    $ java -cp [rvmonitorrt.jar]:[monitor directory] TestWithMain

To simplify the commands required to run the tests, we recommend adding the RV-Monitor runtime
to the system CLASSPATH, precluding the need for manual inclusion.  See the `Examples`_ section
for more information.  If you have correctly modified your system CLASSPATH you will be able
to run programs as follows:

.. code-block:: none

    $ javac InstrumentedProgram(s) MonitorLibrary
    $ java TestWithMain

As an example, considering the existence of an ``rvm`` folder housing
``HasNext.rvm`` and its generated property library,
``HasNextRuntimeMonitor.java``.
A command to compile would be:

.. code-block:: none

    $ javac Test.java SafeIterator.java rvm/HasNextRuntimeMonitor.java

We now run and see program errors with:

.. code-block:: none

    $ java Test
        ! hasNext() has not been called before calling next() for an iterator
        ! hasNext() has not been called before calling next() for an iterator
        ! hasNext() has not been called before calling next() for an iterator
        sum: 15

See the `Examples`_ section for more information on running the bundled examples.

AspectJ Instrumentation
-----------------------

Frequently, it is not desirable to manually insert calls to the monitoring
library in your source.
For reasons of separation of concerns, correctness, ease of use, or 
maintainability, it is very common in the runtime verification community to
use `Aspect-Oriented programming 
<https://en.wikipedia.org/wiki/Aspect-oriented_programming>`_
to instrument large codebases automatically.

Rather than including our calls to the ``HasNextRuntimeMonitor`` events
in our Java source manually, we can create an
`AspectJ <https://eclipse.org/aspectj/>`_ aspect that calls 
them for all instances of ``next()`` and ``hasNext()`` in the program.
This aspect can then be weaved throughout any program to make *all* uses
of ``Iterators`` safe.
What follows is an example of an aspect that can achieve this effect. ::

    aspect HasNextAspect {
        after(Iterator i) : call(* Iterator.hasNext()) && target(i) {
            rvm.HasNextRuntimeMonitor.hasnextEvent(i);
        }
	
        after(): before(Iterator i) : call(* Iterator.next()) && target(i) {
            rvm.HasNextRuntimeMonitor.nextEvent(it);
        }
    }

.. note:: RV-Monitor can access a whole data base of properties that may be
    configured using AspectJ and run against a program as a large scale
    dynamic property checker.
    For your convenience, we have precompiled a suite of common Java API
    protocol properties together in an agent that is automatically invoked
    when you replace ``java`` with ``rv-monitor-all`` in your command line.


.. note:: For more information on using RV-Monitor with Aspects, we
    recommend the `JavaMOP <http://fsl.cs.illinois.edu/javamop/>`_ project, which
    provides automatic instrumentation through AspectJ for your RV-Monitor
    properties and allows you to write a single file which contains both the
    desired properties and the desired instrumentation.

Testing with RV-Monitor
-----------------------
There are several ways to use RV-Monitor.
One is to insert code to recovery from safety errors in your monitoring
library, increasing the safety of your program and providing lightweight
formal guarantees.
RV-Monitor can also be used as a debugger, logging errors when they
occur and giving a developer increased insight as to the execution of
their program and the order of their events.

For example, we can use the following property to ensure mutual exclusion
between calls to `hashcode()` and list modification::

	enforce SafeListCFG(List l) {
	  
	  event beforehashcode(List l) {}
	  event afterhashcode(List l) {}
	  event beforemodify(List l) {}
	  event aftermodify(List l) {}
	
	  cfg :
	    S −> A S | B S | epsilon,
	    A −> A beforehashcode A afterhashcode | epsilon,
	    B −> B beforemodify B aftermodify | epsilon
	
	@nonfail {}
	
	@deadlock { System.out.println(”Deadlock detected!”); }
	
	}
	
The property is parametric in the list, so operations on different list
instances will not interfere with each other. There are four types of events in
this property: `beforehashcode` and `afterhashcode` indicate the start and end
of the execution of `hashCode`, and `beforemodify` and `aftermodify` represent
the start and end of all the modification methods on `ArrayList`.  The property
is defined using a CFG, which allows us to pair the start and the end events of
the execution of `hashCode` or of modification methods.  While the execution of
`hashCode` is in progress (event `afterhashcode` has not been encountered), the
execution of any modification methods is not allowed (event `beforemodify` is
not allowed).

If a violation of this property occurs, an error is reported to the developer.

Specification Language
----------------------

We introduce the RV-Monitor input language through the below BNF grammar,
which is extended with {p} for zero or more and [p] for zero or one p's:

.. code-block:: none
	
	<RV-Monitor Specification> 
                        ::= {<Modifier>} <Id> ["(" <Java Parameters> ")"] "{"
                       		<Java Declarations>
                        	{<Event>}
                        	{<Property>
                        	{"@" <LOGIC State>  "{" <Java Statements> "}"}}
                        "}"
	<Modifier>          ::= "unsynchronized" | "decentralized" | "perthread" | "suffix"
	<Event>             ::= ["creation"] "event" <Id> "(" <Java Parameters> ")" "{" [ <Java Statements> ] "}"
   	<Property>          ::= <LOGIC Name> ":" <LOGIC Syntax>
   	<Java Declarations> ::= ... <!-- syntax of declarations in Java -->
	<Java Parameters>   ::= ... <!-- syntax of method parameter list in Java -->
	<Java Statements>   ::= ... <!-- slightly extended syntax of statements in Java --> 

`<Modifier>`
The modifier unsynchronized tells RV-Monitor that the monitor state need not be
protected against concurrent accesses; the default is synchronized. The
unsynchronized monitor is faster, but may suffer from races on its state
updates if the monitored program has multiple threads. The decentralized
modifier refers to decentralized monitor indexing. The default indexing is
centralized, meaning that the indexing trees needed to quickly access and
garbage-collect monitor instances are stored in a common place; decentralized
indexing means that the indexing trees are scattered all over the code as
additional fields of objects of interest. Decentralized indexing typically
yields lower runtime overhead, though it may not always work for all settings.
Our `OOPSLA'07 paper <http://fsl.cs.illinois.edu/index.php/MOP:_An_Efficient_and_Generic_Runtime_Verification_Framework>`_ 
explains how centralized and decentralized indexing work.

`<Java Parameters> and <Java Declarations>` 
These are ordinary Java parameters (as used in methods) and Java declarations.
The former are the parameters of the RV-Monitor specification and the latter
are additional monitor variables that one can access and modify in both event
actions and property handlers (see below).

`<Event>` 
The event declaration code allows for the definition of events which may then
be referred to in the property. As part of its defining AspectJ advice, an
event can also have arbitrary code associated with it, called an event action,
which is run when the event is observed; an event action can modify the program
or the monitor state. The event action is represented, in the grammar, by the
optional `<Java Statements>` within the braces at the end of the event
definition.

`<Property>` 
Properties are optional in RV-Monitor. A property consists of a named formalism
(`<LOGIC Name>`), followed by a colon, followed by a property specification using
the named formalism (`<LOGIC Syntax>`) and usually referring to the declared
events. RV-Monitor is not bound to any particular property specification
formalism. New formalisms can be added to a RV-Monitor installation by means of
logic plugins. Each logic plugin comes with the following syntactic categories
that are documented on each logic plugin page: `<LOGIC Name>` is the name of the
logic, e.g., ere for extended regular expressions; `<LOGIC Syntax>` is the syntax
that the named logic provides to express properties; `<LOGIC State>` names the
states of monitors generated for the named logic to which one can associate
handlers (see below). The current version of RV-Monitor provides the following
plugins:

- **FSM**     -- Finite State Machines
- **ERE**     -- Extended Regular Expressions
- **CFG**     -- Context Free Grammars
- **PTLTL**   -- Past Time Linear Temporal Logic
- **LTL**     -- Linear Temporal Logic
- **PTCARET** -- Past Time LTL with Calls and Returns
- **SRS**     -- String Rewriting Systems
 
If the property is missing, then the RV-Monitor specification is called raw.
Raw specifications are useful when no existing logic plugin is powerful or
efficient enough to specify the desired property; in that case, one embeds the
custom monitoring code manually within the event generation code.

`"@"<LOGIC State>` 
This syntax allows us to define property handlers, which consist of arbitrary
Java code that will be invoked whenever a certain state is reached in the
generated monitor (e.g., validation or violation in linear temporal logic
specifications, or a particular state in a finite state machine description).
At least one handler is required anytime there is a property (i.e., anytime we
are not using a raw monitor).

`<Java Statement>` 
The Java code used in RV-Monitor specifications slightly extends Java with
two special variables:
__RESET: a special expression (evaluates to void) that resets the monitor to its initial state;
__LOC: a string variable that evaluates to the line number generating the current event;
__MONITOR: a special variable that evaluates to the current monitor object, so that one can read/write monitor variables.

Command Line Usage
--------------------

.. note:: To call rv-monitor with ease, please add `rv-monitor/bin` to your `PATH` 
    and ensure that all specification files have the .rvm file extension. 

The 'rv-monitor' script has the following usage:

.. code-block:: none
	
	 rv-monitor [-v] [-d <target directory>] <specification file or dir>

    	-v option is verbose mode 
    	-d option is used to specify the target directory
        	where the resulting java code will be saved. It is optional.
    
For more options, type `rv-monitor` or `rv-monitor -h`

When you execute a monitored program with Java, you need to include the RV-Monitor Runtime 
Library, as well as your current directory, in your Java classpath. The RV-Monitor 
Runtime Library is provided in this package in the rv-monitor/lib directory. 
A typical value of this is:

In Windows,
  rv-monitor\\lib\\rvmonitorrt.jar

In Linux and Mac,
  rv-monitor/lib/rvmonitorrt.jar

Add this to the left end of the CLASSPATH followed by `;.` (in Windows) or `:.`
(in Linux and Mac). The second part (`:.` i.e. *this* directory) is for ease of use. It
identifies the directory which houses the monitor directory, which is conventionally /rvm.
We assume you will call java and javac from the directory which contains the rvm folder. 

.. note:: Optionally, you can choose to include `-cp [rvmonitor.jar]:[monitor directory with .rvm and generated libraries]` 
    when you compile with javac and run with java to avoid editing your CLASSPATH.

.. code-block:: none

 Options enabled by default are prefixed with '+'
    -h -help              print this help message
    -v | -verbose         enable verbose output
    -debug            enable verbose error message

    -local          + use local logic engine
    -remote           use default remote logic engine
                  http://fsl.cs.uiuc.edu/jsps/logic-2.2.php
                  (You can change the default address
                   in com/runtimeverification/rvmonitor/java/rvj/config/remote_server_addr.properties)
    -remote:<server address>      use remote logic engine

    -d <output path>          select directory to store output files
    -n <name>             use the given class name instead of source code name

    -s | -statistics          generate monitor with statistics
    -noopt1           don't use the enable set optimization

    -finegrainedlock          use fine-grained lock for internal data structure
    -weakrefinterning         use WeakReference interning in indexing trees

Examples
--------

Remember, before trying any examples, please ensure you've added the `rv-monitor/bin` directory to your PATH
and `rv-monitor/lib/rvmonitorrt.jar:.` to the beginning of your CLASSPATH.

This ensures easy use of 1) rv-monitor to generate monitoring libraries, 2) javac to compile
the libraries together with your instrumented program, and 3) java to run the code in all the 
examples.

To get started, here's an example of monitoring via context free grammar.

In examples/java/CFG/HasNext, we call

.. code-block:: none

    $ rv-monitor rvm/HasNext.rvm
    $ javac rvm/HasNextRuntimeMonitor.java HasNext_1/HasNext_1.java
    $ java HasNext_1.HasNext_1

HasNext_1 demonstrates RV-Monitor used to detect unsafe programming practice.
    In HasNext_1.java, a programmer calls next() on an Iterator without first
    calling hasNext() to check if there is another item available. RV-Monitor
    warns the user every time this is done.

Now that we've already compiled the monitor, we must only call

.. code-block:: none

    $ javac HasNext_2/HasNext_2.java
    $ java HasNext_2.HasNext_2

HasNext_2 demonstrates RV-Monitor used to enforce safe programming practice.
    In HasNext_2.java, a programmer correctly calls hasNext() on an Iterator
    before calling next(). RV-Monitor does not display any warnings in the
    terminal.

.. note:: If you navigate to the directory containing the rvm folder in each example and compile and run the code there, 
    you will be able to use the *same exact structure* as the commands in this example. That is,
    you will not have to manually tell javac and java the location of rvmonitorrt.jar or the directory in which your rvm directory dwells! 
    The modification you have already made to your CLASSPATH environment variable will accomodate this. 

Each directory in rv-monitor/examples/java demonstrates different logic types used to enforce 
our monitoring.  Please continue to the next page in the documentation to see all the commands
required to run a selection of these examples and the explanation of these examples.
