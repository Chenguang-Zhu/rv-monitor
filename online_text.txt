==Overview==

RV-Monitor is a software development and analysis framework aiming at reducing
the gap between formal specification and implementation by allowing them
together to form a system. With RV-Monitor, runtime monitoring is supported and
encouraged as a fundamental principle for building reliable software: monitors
are automatically synthesized from specified properties and integrated into the
original system to check its dynamic behaviors during execution. When a
specification is violated or validated at runtime, user-defined actions will be
triggered, which can be any code from information logging to runtime recovery.
One can understand RV-Monitor from at least four perspectives: as a discipline
allowing one to improve safety, reliability and dependability of a system by
monitoring its requirements against its implementation at runtime; as an
extension of programming languages with logics (one can add logical statements
anywhere in the program, referring to past or future states); as a means to
*enforce* specifications in multi-threaded programs; and as a lightweight
formal method.

RV-Monitor takes as input a speification file and generates a Java class
which implements the monitoring functionality.  Each specification defines
a number of *events*, which represent abstractions of certain points in programs,
e.g., a call to the +hasNextNext()+ method in Java, or closing a file.  With these
event abstractions in mind, a user can define one or more properties over the events,
taking the events as either atoms in logical formulae or as symbols in formal
language descriptions.  For example, one may use these events as symbols in a regular
expression or as atoms in a linear temporal logic formula. In the generated Java class,
each event becomes a method that can be either called manually by a user or by using
some means of instrumentation, such as AspectJ.  Each specification also has a number
of handlers associated with each property that run when their associated property
matches some specific conditions.  For instance, when a regular expression pattern
matches, we run a handler designated with the keyword +@match+, and when an LTL
formula is violated, we run a handler designated with the keyword +@violation+. 
As mentioned, handlers are run by the Java class as needed, however, we also export
a number of boolean variables that allow for external testing of the different 
*categories* (e.g., match or violation) that a property may flag.  Additionally,
RV-Monitor has the capable to generate monitors that enforce a given property
by delaying threads in multi-threaded programs. 

==RV-Monitor Uses==

RV-Monitor has a number of uses:

1)  RV-Monitor can be used as a testing framework that uses properties to
enforce a desired thread schedule.  Any time an event occurs which could 
violate a property, that thread is put to sleep until such time that it may continue.
A special deadlock handler is able to run when all threads become deadlocked due
to an infeasible schedule.

2)  RV-Monitor event methods can be called form instrumentation, for instance,
one can call them using AspectJ.  It is possible to write an AspectJ file that
calls a given event method every place that event method needs to occur.

3) RV-Monitor event methods can be manually called from code.  This allows for
fine grain use of RV-Monitor monitors as a programming paradigm.

4) RV-Monitor can access a whole data base of properties that may be run against
a program as a large scale dynamic property checker.  (this point seems sort of out
of place with the others)

==RV-Monitor Language==

==Command Line Option==

 Options enabled by default are prefixed with '+'
    -h -help			  print this help message
    -v | -verbose		  enable verbose output
    -debug			  enable verbose error message

    -local			+ use local logic engine
    -remote			  use default remote logic engine
				  http://fsl.cs.uiuc.edu/jsps/logic-2.2.php
				  (You can change the default address
	 in com/runtimeverification/rvmonitor/java/rvj/config/remote_server_addr.properties)
    -remote:<server address>	  use remote logic engine

    -d <output path>		  select directory to store output files
    -n | -aspectname <aspect name>	  use the given aspect name instead of source code name

    -showevents			  show every event/handler occurrence
    -showhandlers			  show every handler occurrence

    -s | -statistics		  generate monitor with statistics
    -noopt1			  don't use the enable set optimization
    -javalib			  generate a java library rather than an AspectJ file

    -finegrainedlock		  use fine-grained lock for internal data structure
    -weakrefinterning		  use WeakReference interning in indexing trees

    -aspect:"<command line>"	  compile the result right after it is generated
