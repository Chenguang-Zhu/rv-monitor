package com.runtimeverification.rvmonitor.examples.llvmmop;

import com.runtimeverification.rvmonitor.c.rvc.Main;
import com.runtimeverification.rvmonitor.util.Tool;
import org.apache.commons.io.FileUtils;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

/**
 * Base class for llvmmop examples JUnit tests.
 * @author TraianSF
 */
@RunWith(Parameterized.class)
public class LlvmMopExamplesTest {
    public static final String RVC = "__RVC_";
    public static final String MONITOR_BC = "_Monitor.bc";
    private final String specPath;
    private final String specName;
    private final File specFile;
    private final FileSystem fileSystem;
    private final Path specPathParent;


    public LlvmMopExamplesTest(String specPath, String specName) {
        this.specName = specName;
        this.specPath = specPath;
        fileSystem = FileSystems.getDefault();
        specPathParent = fileSystem.getPath(specPath).getParent();
        specFile = specPathParent.toFile();
    }

    private void createMonitor() throws IOException {
        deleteFiles(false,
                RVC + specName + MONITOR_BC,
                "Makefile",
                "Makefile.instrument",
                "aspect.map"
        );
        Main.main(new String[]{"-llvm", specPath});
        relocateFiles(
                RVC + specName + MONITOR_BC,
                "Makefile.instrument",
                "Makefile.new",
                "aspect.map"
        );

        Files.move(
                fileSystem.getPath(specPathParent.toString(), "Makefile.new"),
                fileSystem.getPath(specPathParent.toString(), "Makefile")
        );
    }


    /**
     * Tests the usual build-test-instument-test-uninstrument-test cycle.
     * Matches precomputed expected output files against the output generated by the tests.
     * @throws Exception
     */
    @Test
    public void testTest() throws Exception {
        createMonitor();
        testCommand(null, "make", "clean");
        testCommand(null, "make");
        testCommand("tests/original", "make", "-f", "Makefile.original", "test");
        testCommand(null, "make", "instrument");
        testCommand("tests/instrumented", "make", "-f", "Makefile.original", "test");
        testCommand(null, "make", "uninstrument");
        testCommand("tests/original", "make", "-f", "Makefile.original", "test");
        testCommand(null, "make", "clean");
        deleteFiles(false,
                RVC + specName + MONITOR_BC,
                "Makefile",
                "Makefile.instrument",
                "aspect.map",
                "tests/original.actual.out",
                "tests/original.actual.err",
                "tests/instrumented.actual.out",
                "tests/instrumented.actual.err"
        );

    }

    private void testCommand(String expectedFilePrefix, String... command) throws Exception {
        ProcessBuilder processBuilder = new ProcessBuilder(command).inheritIO();
        processBuilder.directory(specFile);
        String actualOutFile = null;
        String testsPrefix;
        String actualErrFile = null;
        String expectedOutFile = null;
        String expectedErrFile = null;
        if (expectedFilePrefix != null) {
            testsPrefix = specPathParent.toString() + "/" + expectedFilePrefix;
            actualOutFile = testsPrefix + ".actual.out";
            actualErrFile = testsPrefix + ".actual.err";
            expectedOutFile = testsPrefix + ".expected.out";
            expectedErrFile = testsPrefix + ".expected.err";
            processBuilder.redirectError(new File(actualErrFile));
            processBuilder.redirectOutput(new File(actualOutFile));
        }
        Process process = processBuilder.start();
        int returnCode = process.waitFor();
        Assert.assertEquals("Expected no error during" + Arrays.toString(command) + ".", 0, returnCode);
        if (expectedFilePrefix != null) {
            Assert.assertEquals(actualOutFile + " should match " + expectedOutFile, Tool.convertFileToString(expectedOutFile),
                    Tool.convertFileToString(actualOutFile));
            Assert.assertEquals(actualErrFile + "should match " + expectedErrFile, Tool.convertFileToString(expectedErrFile),
                    Tool.convertFileToString(actualErrFile));
        }
    }

    private void relocateFiles(String... files) throws IOException {
        for (String s : files) {
            Path path = fileSystem.getPath(specPathParent.toString(), s);
            Files.move(
                    fileSystem.getPath(s),
                    path
            );
        }
    }

    private void deleteFiles(boolean fail, String... files) throws IOException {
        for (String s : files) {
            Path toDelete = fileSystem.getPath(specPathParent.toString(), s);
            if (fail) {
                Files.delete(toDelete);
            } else {
                Files.deleteIfExists(toDelete);
            }
        }
    }

    @Parameterized.Parameters(name="{0}")
    public static Collection<Object[]> data() {
        Collection<Object[]> data = new ArrayList<Object[]>();
        for (File rvmFile : FileUtils.listFiles(new File("examples/llvmmop"), new String[]{"rvm"}, true)) {
            String rvmFileName = rvmFile.getName();
            String fileName = rvmFileName.substring(0, rvmFileName.lastIndexOf('.'));
            String[] parts = fileName.split("_");
            String specPath = rvmFile.getPath();
            String specName = "";
            for (String part : parts) {
                specName += Character.toUpperCase(part.charAt(0)) + part.substring(1);
            }
            data.add(new Object[] {specPath, specName});
        }
        return data;
    }
}
